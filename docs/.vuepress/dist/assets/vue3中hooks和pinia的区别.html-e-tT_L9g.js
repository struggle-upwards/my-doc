import{_ as e,c as o,o as i,a}from"./app-DjAegRR8.js";const n={},s=a('<h1 id="vue-pinia与vue-hooks-composition-api-的关键差异" tabindex="-1"><a class="header-anchor" href="#vue-pinia与vue-hooks-composition-api-的关键差异"><span><a href="https://segmentfault.com/a/1190000044739572" target="_blank" rel="noopener noreferrer">vue pinia与vue hooks(Composition API)的关键差异</a></span></a></h1><h2 id="vue-pinia的用途" tabindex="-1"><a class="header-anchor" href="#vue-pinia的用途"><span>vue pinia的用途</span></a></h2><p>用于全局状态共享。</p><h2 id="vue-hooks-composition-api-的用途" tabindex="-1"><a class="header-anchor" href="#vue-hooks-composition-api-的用途"><span>vue hooks(Composition API)的用途</span></a></h2><p>用于逻辑封装与复用（注意这里没有状态共享）。</p><h2 id="两者之间关键差异" tabindex="-1"><a class="header-anchor" href="#两者之间关键差异"><span>两者之间关键差异</span></a></h2><p><code>vue pinia</code>是一个单例，也就是说多次初始化实例都是同一个，所以在多个组件中使用时，他们修改的时同一份数据，也就能实现<code>vue pinia</code>的设计目的，即数据共享。</p><p>而<code>vue hooks</code>则不是，每次初始化都会创建一个独立的实例，所以在多个组件中使用时，他们修改的是自己的数据。 当然你也可以用<code>vue hooks</code>通过一些手段来实现<code>vue pinia</code>的效果，但当你做完这些，其最终形态也就相当于一个<code>vue pinia</code>了。</p>',8),p=[s];function t(h,c){return i(),o("div",null,p)}const r=e(n,[["render",t],["__file","vue3中hooks和pinia的区别.html.vue"]]),l=JSON.parse('{"path":"/note/Vue/vue3/vue3%E4%B8%ADhooks%E5%92%8Cpinia%E7%9A%84%E5%8C%BA%E5%88%AB.html","title":"vue pinia与vue hooks(Composition API)的关键差异","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"vue pinia的用途","slug":"vue-pinia的用途","link":"#vue-pinia的用途","children":[]},{"level":2,"title":"vue hooks(Composition API)的用途","slug":"vue-hooks-composition-api-的用途","link":"#vue-hooks-composition-api-的用途","children":[]},{"level":2,"title":"两者之间关键差异","slug":"两者之间关键差异","link":"#两者之间关键差异","children":[]}],"git":{},"filePathRelative":"note/Vue/vue3/vue3中hooks和pinia的区别.md"}');export{r as comp,l as data};
